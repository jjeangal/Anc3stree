{
  "language": "Solidity",
  "sources": {
    "chain/FEVM-Hardhat-Kit/contracts/FamilyTree.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport {ArrayUtils} from \"./lib/ArrayUtils.sol\";\n\ncontract FamilyTree {\n\n    using ArrayUtils for uint256[];\n\n    struct Human {\n        string fullName;\n        string birthDate;\n        string birthPlace;\n        string deathDate;\n        string deathPlace;\n        uint256 leftParentId;\n        uint256 rightParentId;\n    }\n\n    struct Tree {\n        uint256[] familyMembersIds;\n    }\n\n    mapping(uint256 => Human) public humans;\n\n    mapping(uint256 => Tree) private trees;\n\n    mapping(address => uint256) private treeManagers;\n\n    mapping(address => uint256) private humanManagers;\n\n    constructor() {}\n\n    function createHuman(\n        string calldata fullName,\n        string calldata birthDate,\n        string calldata birthPlace,\n        string calldata deathDate,\n        string calldata deathPlace,\n        uint256 leftParentId,\n        uint256 rightParentId\n    ) external returns (uint256) {\n        uint256 id = uint256(keccak256(abi.encodePacked(fullName, birthDate)));\n        humans[id] = Human(\n            fullName,\n            birthDate,\n            birthPlace,\n            deathDate,\n            deathPlace,\n            leftParentId,\n            rightParentId\n        );\n        humanManagers[msg.sender] = id;\n        return id;\n    }\n\n    function addParentsToHuman(uint256 id, uint256 leftParentId, uint256 rightParentId) external {\n        require(humanManagers[msg.sender] == id, \"You are not the manager of this human\");\n        Human storage human = humans[id];\n        human.leftParentId = leftParentId;\n        human.rightParentId = rightParentId;\n    }\n\n    function getHuman(uint256 humanId) external view returns (Human memory) {\n        return humans[humanId];\n    }\n\n    function createTree(uint256 id) external returns (uint256) {\n        uint256[] memory familyMembersIds = new uint256[](0);\n        familyMembersIds[0] = id;\n        uint256 treeId = uint256(keccak256(abi.encodePacked(familyMembersIds)));\n        Tree memory tree = Tree(familyMembersIds);\n        trees[treeId] = tree;\n        treeManagers[msg.sender] = treeId;\n        return treeId;\n    }\n\n    function addMemberToFamilyTree(uint256 memberId, uint256 treeId) external {\n        require(treeManagers[msg.sender] == treeId, \"You are not the manager of this tree\");\n        Tree storage tree = trees[treeId];\n        tree.familyMembersIds.push(memberId);\n    }\n\n    function printFamily(uint256 familyId) external view returns (Human[] memory) {\n        // TODO\n    }\n}\n"
    },
    "chain/FEVM-Hardhat-Kit/contracts/filecoinMockAPIs/MarketAPI.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.25 <=0.8.17;\n\nimport \"./types/MarketTypes.sol\";\n\n/// @title This contract is a proxy to the singleton Storage Market actor (address: f05). Calling one of its methods will result in a cross-actor call being performed. However, in this mock library, no actual call is performed.\n/// @author Zondax AG\n/// @dev Methods prefixed with mock_ will not be available in the real library. These methods are merely used to set mock state. Note that this interface will likely break in the future as we align it\n//       with that of the real library!\ncontract MarketAPI {\n    mapping(string => uint256) balances;\n    mapping(uint64 => MarketTypes.MockDeal) deals;\n\n    constructor() {\n        mock_generate_deals();\n    }\n\n    /// @notice Deposits the received value into the balance held in escrow.\n    /// @dev Because this is a mock method, no real balance is being deducted from the caller, nor incremented in the Storage Market actor (f05).\n    function add_balance(\n        MarketTypes.AddBalanceParams memory params\n    ) public payable {\n        balances[params.provider_or_client] += msg.value;\n    }\n\n    /// @notice Attempt to withdraw the specified amount from the balance held in escrow.\n    /// @notice If less than the specified amount is available, yields the entire available balance.\n    /// @dev This method should be called by an approved address, but the mock does not check that the caller is an approved party.\n    /// @dev Because this is a mock method, no real balance is deposited in the designated address, nor decremented from the Storage Market actor (f05).\n    function withdraw_balance(\n        MarketTypes.WithdrawBalanceParams memory params\n    ) public returns (MarketTypes.WithdrawBalanceReturn memory) {\n        uint256 tmp = balances[params.provider_or_client];\n        if (balances[params.provider_or_client] >= params.tokenAmount) {\n            balances[params.provider_or_client] -= params.tokenAmount;\n            tmp = params.tokenAmount;\n        } else {\n            balances[params.provider_or_client] = 0;\n        }\n\n        return MarketTypes.WithdrawBalanceReturn(tmp);\n    }\n\n    /// @return the escrow balance and locked amount for an address.\n    function get_balance(\n        string memory addr\n    ) public view returns (MarketTypes.GetBalanceReturn memory) {\n        uint256 actualBalance = balances[addr];\n\n        return MarketTypes.GetBalanceReturn(actualBalance, 0);\n    }\n\n    /// @return the data commitment and size of a deal proposal.\n    /// @notice This will be available after the deal is published (whether or not is is activated) and up until some undefined period after it is terminated.\n    /// @dev set data values correctly, currently returning fixed data, feel free to adjust in your local mock.\n    function get_deal_data_commitment(\n        MarketTypes.GetDealDataCommitmentParams memory params\n    ) public view returns (MarketTypes.GetDealDataCommitmentReturn memory) {\n        require(deals[params.id].id > 0);\n\n        return\n            MarketTypes.GetDealDataCommitmentReturn(\n                bytes(\"0x111111\"),\n                deals[params.id].size\n            );\n    }\n\n    /// @return the client of a deal proposal.\n    function get_deal_client(\n        MarketTypes.GetDealClientParams memory params\n    ) public view returns (MarketTypes.GetDealClientReturn memory) {\n        require(deals[params.id].id > 0);\n\n        return MarketTypes.GetDealClientReturn(deals[params.id].client);\n    }\n\n    /// @return the provider of a deal proposal.\n    function get_deal_provider(\n        MarketTypes.GetDealProviderParams memory params\n    ) public view returns (MarketTypes.GetDealProviderReturn memory) {\n        require(deals[params.id].id > 0);\n\n        return MarketTypes.GetDealProviderReturn(deals[params.id].provider);\n    }\n\n    /// @return the label of a deal proposal.\n    function get_deal_label(\n        MarketTypes.GetDealLabelParams memory params\n    ) public view returns (MarketTypes.GetDealLabelReturn memory) {\n        require(deals[params.id].id > 0);\n\n        return MarketTypes.GetDealLabelReturn(deals[params.id].label);\n    }\n\n    /// @return the start epoch and duration (in epochs) of a deal proposal.\n    function get_deal_term(\n        MarketTypes.GetDealTermParams memory params\n    ) public view returns (MarketTypes.GetDealTermReturn memory) {\n        require(deals[params.id].id > 0);\n\n        return\n            MarketTypes.GetDealTermReturn(\n                deals[params.id].start,\n                deals[params.id].end\n            );\n    }\n\n    /// @return the per-epoch price of a deal proposal.\n    function get_deal_total_price(\n        MarketTypes.GetDealEpochPriceParams memory params\n    ) public view returns (MarketTypes.GetDealEpochPriceReturn memory) {\n        require(deals[params.id].id > 0);\n\n        return\n            MarketTypes.GetDealEpochPriceReturn(\n                deals[params.id].price_per_epoch\n            );\n    }\n\n    /// @return the client collateral requirement for a deal proposal.\n    function get_deal_client_collateral(\n        MarketTypes.GetDealClientCollateralParams memory params\n    ) public view returns (MarketTypes.GetDealClientCollateralReturn memory) {\n        require(deals[params.id].id > 0);\n\n        return\n            MarketTypes.GetDealClientCollateralReturn(\n                deals[params.id].client_collateral\n            );\n    }\n\n    /// @return the provider collateral requirement for a deal proposal.\n    function get_deal_provider_collateral(\n        MarketTypes.GetDealProviderCollateralParams memory params\n    ) public view returns (MarketTypes.GetDealProviderCollateralReturn memory) {\n        require(deals[params.id].id > 0);\n\n        return\n            MarketTypes.GetDealProviderCollateralReturn(\n                deals[params.id].provider_collateral\n            );\n    }\n\n    /// @return the verified flag for a deal proposal.\n    /// @notice Note that the source of truth for verified allocations and claims is the verified registry actor.\n    function get_deal_verified(\n        MarketTypes.GetDealVerifiedParams memory params\n    ) public view returns (MarketTypes.GetDealVerifiedReturn memory) {\n        require(deals[params.id].id > 0);\n\n        return MarketTypes.GetDealVerifiedReturn(deals[params.id].verified);\n    }\n\n    /// @notice Fetches activation state for a deal.\n    /// @notice This will be available from when the proposal is published until an undefined period after the deal finishes (either normally or by termination).\n    /// @return USR_NOT_FOUND if the deal doesn't exist (yet), or EX_DEAL_EXPIRED if the deal has been removed from state.\n    function get_deal_activation(\n        MarketTypes.GetDealActivationParams memory params\n    ) public view returns (MarketTypes.GetDealActivationReturn memory) {\n        require(deals[params.id].id > 0);\n\n        return\n            MarketTypes.GetDealActivationReturn(\n                deals[params.id].activated,\n                deals[params.id].terminated\n            );\n    }\n\n    /// @notice Publish a new set of storage deals (not yet included in a sector).\n    function publish_storage_deals(bytes memory raw_auth_params, address callee) public {\n        // calls standard filecoin receiver on message authentication api method number\n        (bool success, ) = callee.call(\n            abi.encodeWithSignature(\n                \"handle_filecoin_method(uint64,uint64,bytes)\",\n                0,\n                2643134072,\n                raw_auth_params\n            )\n        );\n        require(success, \"client contract failed to authorize deal publish\");\n    }\n\n    /// @notice Adds mock deal data to the internal state of this mock.\n    /// @dev Feel free to adjust the data here to make it align with deals in your network.\n    function mock_generate_deals() internal {\n        MarketTypes.MockDeal memory deal_67;\n        deal_67.id = 67;\n        deal_67\n            .cid = \"baga6ea4seaqlkg6mss5qs56jqtajg5ycrhpkj2b66cgdkukf2qjmmzz6ayksuci\";\n        deal_67.size = 8388608;\n        deal_67.verified = false;\n        deal_67.client = \"t01109\";\n        deal_67.provider = \"t01113\";\n        deal_67.label = \"mAXCg5AIg8YBXbFjtdBy1iZjpDYAwRSt0elGLF5GvTqulEii1VcM\";\n        deal_67.start = 25245;\n        deal_67.end = 545150;\n        deal_67.price_per_epoch = 1100000000000;\n        deal_67.provider_collateral = 0;\n        deal_67.client_collateral = 0;\n        deal_67.activated = 1;\n        deal_67.terminated = 0;\n\n        deals[deal_67.id] = deal_67;\n\n        // As EVM smart contract has a limited capacity for size (24KiB), we cannot set all deals directly here.\n        // Please, take them from docs.\n\n        // Add or replace more deals here.\n    }\n}\n"
    },
    "chain/FEVM-Hardhat-Kit/contracts/filecoinMockAPIs/MinerAPI.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.25 <=0.8.17;\n\nimport \"./types/MinerTypes.sol\";\n\n/// @title This contract is a proxy to a built-in Miner actor. Calling one of its methods will result in a cross-actor call being performed. However, in this mock library, no actual call is performed.\n/// @author Zondax AG\n/// @dev Methods prefixed with mock_ will not be available in the real library. These methods are merely used to set mock state. Note that this interface will likely break in the future as we align it\n//       with that of the real library!\ncontract MinerAPI {\n    string owner;\n    bool isBeneficiarySet = false;\n    CommonTypes.ActiveBeneficiary activeBeneficiary;\n    mapping(CommonTypes.SectorSize => uint64) sectorSizesBytes;\n\n    /// @notice (Mock method) Sets the owner of a Miner on contract deployment, which will be returned via get_owner().\n    constructor(string memory _owner) {\n        owner = _owner;\n\n        sectorSizesBytes[CommonTypes.SectorSize._2KiB] = 2 << 10;\n        sectorSizesBytes[CommonTypes.SectorSize._8MiB] = 8 << 20;\n        sectorSizesBytes[CommonTypes.SectorSize._512MiB] = 512 << 20;\n        sectorSizesBytes[CommonTypes.SectorSize._32GiB] = 32 << 30;\n        sectorSizesBytes[CommonTypes.SectorSize._64GiB] = 2 * (32 << 30);\n    }\n\n    /// @notice (Mock method) Sets the owner of a Miner, which will be returned via get_owner().\n    function mock_set_owner(string memory addr) public {\n        require(bytes(owner).length == 0);\n        owner = addr;\n    }\n\n    /// @notice Income and returned collateral are paid to this address\n    /// @notice This address is also allowed to change the worker address for the miner\n    /// @return the owner address of a Miner\n    function get_owner()\n        public\n        view\n        returns (MinerTypes.GetOwnerReturn memory)\n    {\n        require(bytes(owner).length != 0);\n\n        return MinerTypes.GetOwnerReturn(owner);\n    }\n\n    /// @param addr New owner address\n    /// @notice Proposes or confirms a change of owner address.\n    /// @notice If invoked by the current owner, proposes a new owner address for confirmation. If the proposed address is the current owner address, revokes any existing proposal that proposed address.\n    function change_owner_address(string memory addr) public {\n        owner = addr;\n    }\n\n    /// @param params The \"controlling\" addresses are the Owner, the Worker, and all Control Addresses.\n    /// @return Whether the provided address is \"controlling\".\n    function is_controlling_address(\n        MinerTypes.IsControllingAddressParam memory params\n    ) public pure returns (MinerTypes.IsControllingAddressReturn memory) {\n        return MinerTypes.IsControllingAddressReturn(false);\n    }\n\n    /// @return the miner's sector size.\n    function get_sector_size()\n        public\n        view\n        returns (MinerTypes.GetSectorSizeReturn memory)\n    {\n        return\n            MinerTypes.GetSectorSizeReturn(\n                sectorSizesBytes[CommonTypes.SectorSize._8MiB]\n            );\n    }\n\n    /// @notice This is calculated as actor balance - (vesting funds + pre-commit deposit + initial pledge requirement + fee debt)\n    /// @notice Can go negative if the miner is in IP debt.\n    /// @return the available balance of this miner.\n    function get_available_balance()\n        public\n        pure\n        returns (MinerTypes.GetAvailableBalanceReturn memory)\n    {\n        return MinerTypes.GetAvailableBalanceReturn(10000000000000000000000);\n    }\n\n    /// @return the funds vesting in this miner as a list of (vesting_epoch, vesting_amount) tuples.\n    function get_vesting_funds()\n        public\n        pure\n        returns (MinerTypes.GetVestingFundsReturn memory)\n    {\n        CommonTypes.VestingFunds[]\n            memory vesting_funds = new CommonTypes.VestingFunds[](1);\n        vesting_funds[0] = CommonTypes.VestingFunds(\n            1668514825,\n            2000000000000000000000\n        );\n\n        return MinerTypes.GetVestingFundsReturn(vesting_funds);\n    }\n\n    /// @notice Proposes or confirms a change of beneficiary address.\n    /// @notice A proposal must be submitted by the owner, and takes effect after approval of both the proposed beneficiary and current beneficiary, if applicable, any current beneficiary that has time and quota remaining.\n    /// @notice See FIP-0029, https://github.com/filecoin-project/FIPs/blob/master/FIPS/fip-0029.md\n    function change_beneficiary(\n        MinerTypes.ChangeBeneficiaryParams memory params\n    ) public {\n        if (!isBeneficiarySet) {\n            CommonTypes.BeneficiaryTerm memory term = CommonTypes\n                .BeneficiaryTerm(params.new_quota, 0, params.new_expiration);\n            activeBeneficiary = CommonTypes.ActiveBeneficiary(\n                params.new_beneficiary,\n                term\n            );\n            isBeneficiarySet = true;\n        } else {\n            activeBeneficiary.beneficiary = params.new_beneficiary;\n            activeBeneficiary.term.quota = params.new_quota;\n            activeBeneficiary.term.expiration = params.new_expiration;\n        }\n    }\n\n    /// @notice This method is for use by other actors (such as those acting as beneficiaries), and to abstract the state representation for clients.\n    /// @notice Retrieves the currently active and proposed beneficiary information.\n    function get_beneficiary()\n        public\n        view\n        returns (MinerTypes.GetBeneficiaryReturn memory)\n    {\n        require(isBeneficiarySet);\n\n        CommonTypes.PendingBeneficiaryChange memory proposed;\n        return MinerTypes.GetBeneficiaryReturn(activeBeneficiary, proposed);\n    }\n}\n"
    },
    "chain/FEVM-Hardhat-Kit/contracts/filecoinMockAPIs/types/CommonTypes.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.25 <=0.8.17;\n\n/// @title Filecoin actors' common types for Solidity.\n/// @author Zondax AG\nlibrary CommonTypes {\n    enum RegisteredSealProof {\n        StackedDRG2KiBV1,\n        StackedDRG512MiBV1,\n        StackedDRG8MiBV1,\n        StackedDRG32GiBV1,\n        StackedDRG64GiBV1,\n        StackedDRG2KiBV1P1,\n        StackedDRG512MiBV1P1,\n        StackedDRG8MiBV1P1,\n        StackedDRG32GiBV1P1,\n        StackedDRG64GiBV1P1,\n        Invalid\n    }\n\n    enum RegisteredPoStProof {\n        StackedDRGWinning2KiBV1,\n        StackedDRGWinning8MiBV1,\n        StackedDRGWinning512MiBV1,\n        StackedDRGWinning32GiBV1,\n        StackedDRGWinning64GiBV1,\n        StackedDRGWindow2KiBV1,\n        StackedDRGWindow8MiBV1,\n        StackedDRGWindow512MiBV1,\n        StackedDRGWindow32GiBV1,\n        StackedDRGWindow64GiBV1,\n        Invalid\n    }\n\n    enum RegisteredUpdateProof {\n        StackedDRG2KiBV1,\n        StackedDRG8MiBV1,\n        StackedDRG512MiBV1,\n        StackedDRG32GiBV1,\n        StackedDRG64GiBV1,\n        Invalid\n    }\n    enum ExtensionKind {\n        ExtendCommittmentLegacy,\n        ExtendCommittment\n    }\n\n    enum SectorSize {\n        _2KiB,\n        _8MiB,\n        _512MiB,\n        _32GiB,\n        _64GiB\n    }\n\n    struct ValidatedExpirationExtension {\n        uint64 deadline;\n        uint64 partition;\n        uint8 sectors;\n        int64 new_expiration;\n    }\n\n    struct ExtendExpirationsInner {\n        ValidatedExpirationExtension[] extensions;\n        bytes claims; // FIXME this is a BTreeMap<SectorNumber, (u64, u64)> on rust\n    }\n\n    struct PendingBeneficiaryChange {\n        bytes new_beneficiary;\n        int256 new_quota;\n        uint64 new_expiration;\n        bool approved_by_beneficiary;\n        bool approved_by_nominee;\n    }\n\n    struct BeneficiaryTerm {\n        int256 quota;\n        int256 used_quota;\n        uint64 expiration;\n    }\n\n    struct ActiveBeneficiary {\n        string beneficiary;\n        BeneficiaryTerm term;\n    }\n\n    struct RecoveryDeclaration {\n        uint64 deadline;\n        uint64 partition;\n        uint8 sectors;\n    }\n\n    struct FaultDeclaration {\n        uint64 deadline;\n        uint64 partition;\n        uint8 sectors;\n    }\n\n    struct TerminationDeclaration {\n        uint64 deadline;\n        uint64 partition;\n        uint8 sectors;\n    }\n\n    struct SectorClaim {\n        uint64 sector_number;\n        uint64[] maintain_claims;\n        uint64[] drop_claims;\n    }\n\n    struct ExpirationExtension2 {\n        uint64 deadline;\n        uint64 partition;\n        uint8 sectors;\n        SectorClaim[] sectors_with_claims;\n        int64 new_expiration;\n    }\n\n    struct ExpirationExtension {\n        uint64 deadline;\n        uint64 partition;\n        uint8 sectors;\n        int64 new_expiration;\n    }\n\n    struct FilterEstimate {\n        int256 position;\n        int256 velocity;\n    }\n\n    struct SectorPreCommitInfoInner {\n        RegisteredSealProof seal_proof;\n        uint64 sector_number;\n        bytes sealed_cid;\n        int64 seal_rand_epoch;\n        uint64[] deal_ids;\n        int64 expiration;\n        bytes unsealed_cid;\n    }\n\n    struct SectorPreCommitInfo {\n        RegisteredSealProof seal_proof;\n        uint64 sector_number;\n        bytes sealed_cid;\n        int64 seal_rand_epoch;\n        uint64[] deal_ids;\n        int64 expiration;\n        bytes unsealed_cid;\n    }\n    struct ReplicaUpdateInner {\n        uint64 sector_number;\n        uint64 deadline;\n        uint64 partition;\n        bytes new_sealed_cid;\n        bytes new_unsealed_cid;\n        uint64[] deals;\n        RegisteredUpdateProof update_proof_type;\n        bytes replica_proof;\n    }\n\n    struct ReplicaUpdate {\n        uint64 sector_number;\n        uint64 deadline;\n        uint64 partition;\n        bytes new_sealed_cid;\n        uint64 deals;\n        RegisteredUpdateProof update_proof_type;\n        bytes replica_proof;\n    }\n\n    struct ReplicaUpdate2 {\n        uint64 sector_number;\n        uint64 deadline;\n        uint64 partition;\n        bytes new_sealed_cid;\n        bytes new_unsealed_cid;\n        uint64 deals;\n        RegisteredUpdateProof update_proof_type;\n        bytes replica_proof;\n    }\n\n    struct PoStPartition {\n        uint64 index;\n        int8 skipped;\n    }\n\n    struct PoStProof {\n        RegisteredPoStProof post_proof;\n        bytes proof_bytes;\n    }\n\n    struct VestingFunds {\n        int64 epoch;\n        int256 amount;\n    }\n    struct SectorDeals {\n        int64 sector_type;\n        int64 sector_expiry;\n        uint64[] deal_ids;\n    }\n\n    struct Signature {\n        int8 sig_type;\n        bytes data;\n    }\n\n    struct DealProposal {\n        bytes piece_cid;\n        uint64 piece_size;\n        bool verified_deal;\n        bytes client;\n        bytes provider;\n        string label;\n        int64 start_epoch;\n        int64 end_epoch;\n        int storage_price_per_epoch;\n        int provider_collateral;\n        int client_collateral;\n    }\n\n    struct ClientDealProposal {\n        DealProposal proposal;\n        Signature client_signature;\n    }\n\n    struct SectorDealData {\n        bytes commd;\n    }\n\n    struct CID {\n        uint8 version;\n        uint64 codec;\n        Multihash hash;\n    }\n\n    struct Multihash {\n        uint64 code;\n        uint8 size;\n        bytes digest;\n    }\n\n    struct VerifiedDealInfo {\n        uint64 client;\n        uint64 allocation_id;\n        bytes data;\n        uint64 size;\n    }\n\n    struct SectorDataSpec {\n        uint64[] deal_ids;\n        int64 sector_type;\n    }\n}\n"
    },
    "chain/FEVM-Hardhat-Kit/contracts/filecoinMockAPIs/types/MarketTypes.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.25 <=0.8.17;\n\n/// @title Filecoin market actor types for Solidity.\n/// @author Zondax AG\nlibrary MarketTypes {\n    struct MockDeal {\n        uint64 id;\n        string cid;\n        uint64 size;\n        bool verified;\n        string client;\n        string provider;\n        string label;\n        int64 start;\n        int64 end;\n        uint256 price_per_epoch;\n        uint256 provider_collateral;\n        uint256 client_collateral;\n        int64 activated;\n        int64 terminated;\n    }\n\n    struct AddBalanceParams {\n        string provider_or_client;\n    }\n\n    struct WithdrawBalanceParams {\n        string provider_or_client;\n        uint256 tokenAmount;\n    }\n\n    struct WithdrawBalanceReturn {\n        uint256 amount_withdrawn;\n    }\n\n    struct GetBalanceReturn {\n        uint256 balance;\n        uint256 locked;\n    }\n\n    struct GetDealDataCommitmentParams {\n        uint64 id;\n    }\n\n    struct GetDealDataCommitmentReturn {\n        bytes data;\n        uint64 size;\n    }\n\n    struct GetDealClientParams {\n        uint64 id;\n    }\n\n    struct GetDealClientReturn {\n        string client;\n    }\n\n    struct GetDealProviderParams {\n        uint64 id;\n    }\n\n    struct GetDealProviderReturn {\n        string provider;\n    }\n\n    struct GetDealLabelParams {\n        uint64 id;\n    }\n\n    struct GetDealLabelReturn {\n        string label;\n    }\n\n    struct GetDealTermParams {\n        uint64 id;\n    }\n\n    struct GetDealTermReturn {\n        int64 start;\n        int64 end;\n    }\n\n    struct GetDealEpochPriceParams {\n        uint64 id;\n    }\n\n    struct GetDealEpochPriceReturn {\n        uint256 price_per_epoch;\n    }\n\n    struct GetDealClientCollateralParams {\n        uint64 id;\n    }\n\n    struct GetDealClientCollateralReturn {\n        uint256 collateral;\n    }\n\n    struct GetDealProviderCollateralParams {\n        uint64 id;\n    }\n\n    struct GetDealProviderCollateralReturn {\n        uint256 collateral;\n    }\n\n    struct GetDealVerifiedParams {\n        uint64 id;\n    }\n\n    struct GetDealVerifiedReturn {\n        bool verified;\n    }\n\n    struct GetDealActivationParams {\n        uint64 id;\n    }\n\n    struct GetDealActivationReturn {\n        int64 activated;\n        int64 terminated;\n    }\n}\n"
    },
    "chain/FEVM-Hardhat-Kit/contracts/filecoinMockAPIs/types/MinerTypes.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.25 <=0.8.17;\n\nimport \"./CommonTypes.sol\";\n\n/// @title Filecoin miner actor types for Solidity.\n/// @author Zondax AG\nlibrary MinerTypes {\n    struct GetOwnerReturn {\n        string owner;\n    }\n    struct IsControllingAddressParam {\n        string addr;\n    }\n    struct IsControllingAddressReturn {\n        bool is_controlling;\n    }\n    struct GetSectorSizeReturn {\n        uint64 sector_size;\n    }\n    struct GetAvailableBalanceReturn {\n        int256 available_balance;\n    }\n    struct GetVestingFundsReturn {\n        CommonTypes.VestingFunds[] vesting_funds;\n    }\n\n    struct ChangeBeneficiaryParams {\n        string new_beneficiary;\n        int256 new_quota;\n        uint64 new_expiration;\n    }\n\n    struct GetBeneficiaryReturn {\n        CommonTypes.ActiveBeneficiary active;\n        CommonTypes.PendingBeneficiaryChange proposed;\n    }\n}\n"
    },
    "chain/FEVM-Hardhat-Kit/contracts/lib/ArrayUtils.sol": {
      "content": "// SPDX-License-Identifier: Apache License 2.0\npragma solidity ^0.8.13;\n\nlibrary ArrayUtils {\n    function indexOf(address[] memory _array, address a) internal pure returns (uint256, bool) {\n        uint256 length = _array.length;\n        for (uint256 i = 0; i < length; i++) {\n            if (_array[i] == a) {\n                return (i, true);\n            }\n        }\n        return (0, false);\n    }\n\n    function contains(address[] memory _array, address a) internal pure returns (bool) {\n        (, bool isIn) = indexOf(_array, a);\n        return isIn;\n    }\n\n    function hasDuplicate(address[] memory _array) internal pure returns (bool) {\n        require(_array.length > 0, \"_array is empty\");\n\n        for (uint256 i = 0; i < _array.length - 1; i++) {\n            address current = _array[i];\n            for (uint256 j = i + 1; j < _array.length; j++) {\n                if (current == _array[j]) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    function remove(address[] memory _array, address a) internal pure returns (address[] memory) {\n        (uint256 index, bool isIn) = indexOf(_array, a);\n        if (!isIn) {\n            revert(\"Address not in array.\");\n        } else {\n            (address[] memory _newArray,) = pop(_array, index);\n            return _newArray;\n        }\n    }\n\n    /**\n     * @param _array The input array to search\n     * @param a The address to remove\n     */\n    function removeStorage(address[] storage _array, address a) internal {\n        (uint256 index, bool isIn) = indexOf(_array, a);\n        if (!isIn) {\n            revert(\"Address not in array.\");\n        } else {\n            uint256 lastIndex = _array.length - 1; // If the array would be empty, the previous line would throw, so no underflow here\n            if (index != lastIndex) _array[index] = _array[lastIndex];\n            _array.pop();\n        }\n    }\n\n    /**\n     * Removes specified index from array\n     * @param _array The input array to search\n     * @param index The index to remove\n     * @return Returns the new array and the removed entry\n     */\n    function pop(address[] memory _array, uint256 index)\n        internal\n        pure\n        returns (address[] memory, address)\n    {\n        uint256 length = _array.length;\n        require(index < _array.length, \"Index must be < _array length\");\n        address[] memory newAddresses = new address[](length - 1);\n        for (uint256 i = 0; i < index; i++) {\n            newAddresses[i] = _array[i];\n        }\n        for (uint256 j = index + 1; j < length; j++) {\n            newAddresses[j - 1] = _array[j];\n        }\n        return (newAddresses, _array[index]);\n    }\n\n    /**\n     * Returns the combination of the two arrays\n     * @param _array The first array\n     * @param _anotherArray The second array\n     * @return Returns _array extended by _anotherArray\n     */\n    function extend(address[] memory _array, address[] memory _anotherArray)\n        internal\n        pure\n        returns (address[] memory)\n    {\n        uint256 aLength = _array.length;\n        uint256 bLength = _anotherArray.length;\n        address[] memory newAddresses = new address[](aLength + bLength);\n        for (uint256 i = 0; i < aLength; i++) {\n            newAddresses[i] = _array[i];\n        }\n        for (uint256 j = 0; j < bLength; j++) {\n            newAddresses[aLength + j] = _anotherArray[j];\n        }\n        return newAddresses;\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "viaIR": true,
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}